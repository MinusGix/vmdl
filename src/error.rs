use thiserror::Error;

#[non_exhaustive]
#[derive(Debug, Error)]
pub enum ModelError {
    #[error("io error while reading data: {0}")]
    IO(#[from] std::io::Error),
    #[error(transparent)]
    String(#[from] StringError),
    #[error("Malformed field found while parsing: {0:#}")]
    MalformedData(binrw::Error),
    #[error("referenced data to {data} is out of bounds at {offset}")]
    OutOfBounds { data: &'static str, offset: usize },
}

impl From<binrw::Error> for ModelError {
    fn from(e: binrw::Error) -> Self {
        use binrw::Error;

        // only a few error types should be generated by our code
        match e {
            Error::Io(e) => ModelError::IO(e),
            Error::Custom { err, .. } => {
                if err.is::<StringError>() {
                    ModelError::String(*err.downcast::<StringError>().unwrap())
                } else {
                    panic!("unexpected custom error")
                }
            }
            e => ModelError::MalformedData(e),
        }
    }
}

#[derive(Debug, Error)]
pub enum StringError {
    #[error(transparent)]
    NonUTF8(#[from] std::str::Utf8Error),
    #[error("String is not null-terminated")]
    NotNullTerminated,
}
